# RISC-V CPU (VHDL, Vivado)

>A modular RV32I learning core implemented in VHDL, built and simulated with Xilinx Vivado.

This repository contains a simple, modular RISC‑V processor and its building blocks (ALU, controller, register file, instruction/data memories, muxes/decoders, etc.), plus focused testbenches for most components. It’s intended for education and experimentation rather than peak performance.

## Highlights

- RV32I subset with common arithmetic, logic, load/store, branch, and jump instructions
- Clean, parameterized VHDL (word width, RAM depth/width)
- Memory initialization from external .mem files (plain binary per line)
- Separate testbenches for core modules to aid verification
- Vivado project included (`RISC-V.xpr`) for one‑click open/sim/synth

## Repository layout

Key folders and files (paths are relative to this repo root):

- `RISC-V/RISC-V.xpr` — Vivado project
- `RISC-V/RISC-V.srcs/sources_1/new/` — synthesizable VHDL sources
	- `ALU.vhd`, `Adder.vhd`, `Controller.vhd`, `Program_Counter.vhd`
	- `Register_File.vhd`, `Register_Simple.vhd`, `Register_Write_Enable.vhd`
	- `Instruction_Memory.vhd`, `Data_Memory.vhd`, `DRAM.vhd`
	- `Mux_2to1.vhd`, `Mux_4to1.vhd`, `Mux_16to1.vhd`, `Mux_32to1.vhd`
	- `Decoder_2to4.vhd`, `Decoder_4to16.vhd`, `Decoder_5to32.vhd`
	- Memory init files: `instruction_mem_init_file.mem`, `data_mem_init_file.mem`, `rams_init_mem_file.mem`, `default_mem_file.mem`
- `RISC-V/RISC-V.srcs/sim_1/new/` — VHDL testbenches (e.g., `TB_ALU.vhd`, `TB_Controller.vhd`, `TB_Data_Memory.vhd`, …)
- `RISC-V/RISC-V.sim/sim_1/behav/xsim/` — Vivado simulator artifacts and example Tcl scripts
- `RISC-V/RISC-V.runs/` — Vivado synthesis/implementation runs (auto‑generated by Vivado)

## Implemented modules (quick tour)

- ALU (`ALU.vhd`)
	- 32‑bit by default (generic `W`), supports: ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, SLT, SLTU
	- Zero flag output
- Controller (`Controller.vhd`)
	- Decodes opcode/funct fields, drives control lines
	- Handles R/I/S/B/U/J formats, including: ADD/SUB/AND/OR/XOR, shifts, SLT/SLTU, ADDI/ANDI/ORI/XORI, SLLI/SRLI/SRAI, LW/LHU/LBU, SW/SH/SB, BEQ/BNE/BLTU/BGEU, JAL, JALR, LUI, AUIPC
- Program Counter (`Program_Counter.vhd`)
	- Synchronous PC with reset
- Register File (`Register_File.vhd`)
	- 32 × 32‑bit registers, 2 read ports, 1 write port; x0 behavior controlled in surrounding logic
- Memories (`Instruction_Memory.vhd`, `Data_Memory.vhd`, `DRAM.vhd`)
	- Generic depth/width; `.mem` file initialization via TEXTIO
	- Instruction memory uses a ROM‑style DRAM instance; data memory supports synchronous write
- Glue logic
	- Decoders 2→4, 4→16, 5→32
	- Muxes 2→1, 4→1, 16→1, 32→1

## Memory initialization files

Files live in `RISC-V/RISC-V.srcs/sources_1/new/`:

- `instruction_mem_init_file.mem` — program words for instruction memory
- `data_mem_init_file.mem` — initial contents for data memory
- `rams_init_mem_file.mem` — example RAM contents
- `default_mem_file.mem` — placeholder (may be empty)

Format:
- One 32‑bit word per line
- Binary text (e.g., `00010001001000100011001101000100`)
- Default generics: depth 128, width 32, address width 7 (see `DRAM.vhd`)

Update by editing the files directly; Vivado simulation will reload them when the design elaborates.

## Open, simulate, and synthesize (Vivado)

### Quick start (GUI)
1. Open Vivado (tested with 2020.x+).
2. File → Open Project → select `RISC-V/RISC-V.xpr`.
3. In the Sources pane, expand Simulation Sources and pick a testbench (e.g., `TB_ALU.vhd`).
4. Run Simulation → Run Behavioral. Inspect waveforms and console output.
5. For synthesis, click Run Synthesis (or open `RISC-V.runs/synth_1`).

### Optional: run a Tcl script
Vivado generates helper Tcl in `RISC-V/RISC-V.sim/sim_1/behav/xsim/` (e.g., `TB_Decoder_2to4.tcl`). You can invoke Vivado in batch mode from Linux:

```bash
vivado -mode batch -source RISC-V/RISC-V.sim/sim_1/behav/xsim/TB_Decoder_2to4.tcl
```

Replace the Tcl file with the one matching the testbench you want to run.

## Building blocks and generics

- Word width: most modules use generic `W := 32` (RV32). You can retarget to other widths for experiments.
- Memories: `DRAM` generics control `RAM_DEPTH`, `RAM_WIDTH`, `ADDR_WIDTH`, and `MEMORY_FILE` path.
- Controller: opcode map and ALU control encoded per RV32I.

## What’s in scope

This project targets a compact RV32I subset suitable for learning. It is not a pipelined or superscalar core. Typical next steps include pipelining (IF/ID/EX/MEM/WB), hazard handling, CSR/interrupts, and a fuller instruction set.

## How to contribute

- File issues or ideas in the tracker.
- Send PRs with focused changes. Include/extend a testbench when possible.
- Keep VHDL style consistent and prefer generics over hardcoding.

## License

Add your preferred license (e.g., MIT) in `LICENSE`. Until then, all rights reserved by the author(s).

## Acknowledgements

Design and VHDL by Mehmet Arslan. Thanks to the RISC‑V community for specifications and tooling.

